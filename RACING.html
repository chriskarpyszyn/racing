<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8"/>
    <title>TRACK</title>
</head>
<body>
<canvas id="gameCanvas" width="800" height="600"></canvas>
<p id="debugText"></p>

<script>

    var canvas;
    var canvasContext;

    var carX, carY;
    var carSpeed = 0;
    var carSpeedXMultipler = 0.35;
    var carRadius = 10;
    var carAngle = 0;

    var carPic = document.createElement("img");
    var carPicLoaded = false;

    const TRACK_WIDTH = 40;
    const TRACK_HEIGHT = 40;
    const TRACK_GAP = 1;
    const TRACK_COLS = 20;
    const TRACK_ROWS = 15;

    const KEY_UP_ARROW = 38;
    const KEY_DOWN_ARROW = 40;
    const KEY_LEFT_ARROW = 37;
    const KEY_RIGHT_ARROW = 39;

    var keyHeld_Gas = false;
    var keyHeld_Reverse = false;
    var keyHeld_TurnLeft = false;
    var keyHeld_TurnRight = false;

    const INITIAL_CAR_SPEED = 0;

    var debug = false;

    var trackGrid =
    [
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,
        1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
        1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1,
        1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1,
        1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1,
        1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1,
        1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1,
        1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1,
        1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1,
        1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1,
        1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1,
        1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1,
        1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
    ];

    window.onload = function () {
        const fps = 30;
        canvas = document.getElementById('gameCanvas');
        canvasContext = canvas.getContext('2d');

        carPic.onload = function () {
            carPicLoaded = true;
        };
        carPic.src = "player1.png";

        //hack for keydown events. probably a better way to do this.
        //http://stackoverflow.com/questions/15631991/how-to-register-onkeydown-event-for-html5-canvas
        //canvas.tabIndex = 1000;
        //canvas.style.outline = "none";

        resetCar();

        document.addEventListener("keydown", keyPressed);
        document.addEventListener("keyup", keyReleased);

        //canvas.addEventListener('keydown', function(evt) {
        //    var keyCode = evt.keyCode;
        //    //keycode 81 = q
        //    if (keyCode === 81) {
        //        if (debug === true) {
        //            debug = false;
        //        } else {
        //            debug = true;
        //        }
        //    }
        //});

        setInterval(function() {
            move();
            draw();
        }, 1000 / fps);
    };

    function keyPressed(evt) {
        //document.getElementById("debugText").innerHTML = "keyCode Pushed: " + evt.keyCode;

        if (evt.keyCode === KEY_UP_ARROW) {
            keyHeld_Gas = true;
        }
        if (evt.keyCode === KEY_DOWN_ARROW) {
            keyHeld_Reverse = true;
        }
        if (evt.keyCode === KEY_RIGHT_ARROW) {
            keyHeld_TurnRight = true;
        }
        if (evt.keyCode === KEY_LEFT_ARROW) {
            keyHeld_TurnLeft = true;
        }

        evt.preventDefault();

    }

    function keyReleased(evt) {
        //document.getElementById("debugText").innerHTML = "keyCode Released: " + evt.keyCode;

        if (evt.keyCode === KEY_UP_ARROW) {
            keyHeld_Gas = false;
        }
        if (evt.keyCode === KEY_DOWN_ARROW) {
            keyHeld_Reverse = false;
        }
        if (evt.keyCode === KEY_RIGHT_ARROW) {
            keyHeld_TurnRight = false;
        }
        if (evt.keyCode === KEY_LEFT_ARROW) {
            keyHeld_TurnLeft = false;
        }

        evt.preventDefault();
    }

    function move() {

      if (keyHeld_Gas) {
        carSpeed += 0.3;
      }
      if (keyHeld_Reverse) {
        carSpeed += -0.3;
      }
      if (keyHeld_TurnRight) {
        carAngle += 0.03*Math.PI;
      }
      if (keyHeld_TurnLeft) {
        carAngle += -0.03*Math.PI;
      }

        //const carLeft = carX - carRadius;
        //const carRight = carX + carRadius;
        //const carTop = carY - carRadius;

        /////todo: BUG, car get's stuck in the side on some collisions
        //if (carLeft < 0) {
        //    carSpeedX *= -1;
        //}

        //if (carRight > canvas.width) {
        //    carSpeedX *= -1;
        //}

        //if (carTop < 0) {
        //    carSpeedY *= -1;
        //}

        //if (carTop >= canvas.height) {
        //    resetCar();
        //}

        /////todo: need to fix carX, carY to detect at outer edge of circle and not center (clipping issues)
        //BounceOffTrackAtPixelCoord(carX, carY);

        carX += Math.cos(carAngle) * carSpeed;
        carY += Math.sin(carAngle) * carSpeed;

    }

    function draw() {
        colorRect(0, 0, canvas.width, canvas.height, '#000000');

        drawTracks();

        drawCar();

        drawDebug();
    }

    function drawCar() {
        //carAngle += 0.2;
        if (carPicLoaded) {
            drawBitmapCenteredAtLocationWithRotation(carPic, carX, carY, carAngle);
        }
    }

    function drawBitmapCenteredAtLocationWithRotation(graphic, x, y, withAngle) {
        canvasContext.save(); //allows us to undo translate movement and rotate spinm
        canvasContext.translate(x, y); //sets point where graphic goes
        canvasContext.rotate(withAngle); // sets the roation
        canvasContext.drawImage(graphic, -graphic.width / 2, -graphic.height / 2); //center and draw
        canvasContext.restore(); //undo the translation movement and rotation since save()
    }

    function drawTracks() {
        for (var i = 0; i < TRACK_COLS; i++) {
            for (var j = 0; j < TRACK_ROWS; j++) {

                if (isTrackAtTileCoord(i, j)) {
                    colorRect((i * TRACK_WIDTH), (j * TRACK_HEIGHT), TRACK_WIDTH - TRACK_GAP,
                    TRACK_HEIGHT - TRACK_GAP, '#862d2d');
                }
            }
        }
    }

    function colorRect(topLeftX, topRightY, boxWidth, boxHeight, fillColor) {
        canvasContext.fillStyle = fillColor;
        canvasContext.fillRect(topLeftX, topRightY, boxWidth, boxHeight);
    }

    function colorCircle(centerX, centerY, radius, fillColor) {
        canvasContext.fillStyle = fillColor;
        canvasContext.beginPath();
        canvasContext.arc(centerX, centerY, radius, 0, Math.PI * 2, true);
        canvasContext.fill();
    }

    function resetCar() {
        carX = canvas.width / 2;
        carY = canvas.height / 2;
        carSpeed = INITIAL_CAR_SPEED;
    }

    function trackTileToIndex(tileCol, tileRow) {
        return tileCol + tileRow * TRACK_COLS;
    }

    function isTrackAtTileCoord(trackTileCol, trackTileRow) {
        var trackIndex = trackTileToIndex(trackTileCol, trackTileRow);
        return (trackGrid[trackIndex] === 1);
    }

    function BounceOffTrackAtPixelCoord(pixelX, pixelY) {
        var tileCol = Math.floor(pixelX / TRACK_WIDTH);
        var tileRow = Math.floor(pixelY / TRACK_HEIGHT);

        if (tileCol < 0 || tileCol >= TRACK_COLS || tileRow < 0 || tileRow >= TRACK_ROWS) {
            return;
        }

        var trackIndex = trackTileToIndex(tileCol, tileRow);

        if (trackGrid[trackIndex] === 1) {
            var prevCarX = pixelX - carSpeed;
            var prevCarY = pixelY - carSpeed;
            var prevTileCol = Math.floor(prevCarX / TRACK_WIDTH);
            var prevTileRow = Math.floor(prevCarY / TRACK_HEIGHT);

            var bothTestFailed = true;

            ///todo: getting weird bounces where both tileCol!=prevtilecol and tileRow!=prevtilerow
            var adjacentTrackIndex;
            if (tileCol !== prevTileCol) {
                adjacentTrackIndex = trackTileToIndex(prevTileCol, tileRow);
                if (trackIndex[adjacentTrackIndex] !== 1) {
                    carSpeed *= -1;
                    bothTestFailed = false;
                }
            }
            if (tileRow !== prevTileRow) {
                adjacentTrackIndex = trackTileToIndex(tileCol, prevTileRow);
                if (trackIndex[adjacentTrackIndex] !== 1) {
                    carSpeedY *= -1;
                    bothTestFailed = false;
                }
            }

            if (bothTestFailed) {
                carSpeed *= -1;
                carSpeed *= -1;
            }
        }
    }

    function drawDebug() {
        if (debug) {

            var carSize = 2.5;

            colorCircle(carX, carY - carRadius, carSize, 'red');
            colorCircle(carX, carY + carRadius, carSize, 'green');
            colorCircle(carX - carRadius, carY, carSize, 'blue');
            colorCircle(carX + carRadius, carY, carSize, 'cyan');

        }
    }
</script>

</body>
</html>
